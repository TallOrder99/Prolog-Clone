package compiler;

import ast.*; // Import all our AST classes
import generated.LogicMiniBaseVisitor;
import generated.LogicMiniParser;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This visitor class walks the parse tree generated by ANTLR
 * and builds our custom Abstract Syntax Tree (AST).
 */
public class ASTGenerator extends LogicMiniBaseVisitor<Object> {
    @Override
    public Program visitProgram(LogicMiniParser.ProgramContext ctx) {
        List<Clause> clauses = new ArrayList<>();
        // 1. Visit all clauses
        for (LogicMiniParser.ClauseContext c : ctx.clause()) {
            clauses.add((Clause) visit(c));
        }

        // 2. Visit query if it exists
        List<Term> queryGoals = new ArrayList<>();
        if (ctx.query() != null) {
            // query -> Q_MARK_DASH term_list DOT
            queryGoals = (List<Term>) visit(ctx.query().term_list());
        }

        return new Program(clauses, queryGoals);
    }

    @Override
    public Clause visitFactRule(LogicMiniParser.FactRuleContext ctx) {
        // Fact: cat(tom). -> Head: cat(tom), Body: Empty
        Structure head = (Structure) visit(ctx.structure());
        return new Clause(head, new ArrayList<>());
    }

    @Override
    public Clause visitRuleRule(LogicMiniParser.RuleRuleContext ctx) {
        // Rule: A :- B, C.
        Structure head = (Structure) visit(ctx.structure());
        List<Term> body = (List<Term>) visit(ctx.term_list());
        return new Clause(head, body);
    }

    @Override
    public List<Term> visitTerm_list(LogicMiniParser.Term_listContext ctx) {
        List<Term> terms = new ArrayList<>();
        for (LogicMiniParser.TermContext t : ctx.term()) {
            terms.add((Term) visit(t));
        }
        return terms;
    }

    @Override
    public Structure visitStructureTerm(LogicMiniParser.StructureTermContext ctx) {
        String functor = ctx.ATOM().getText();
        List<Term> args = (List<Term>) visit(ctx.term_list());
        return new Structure(functor, args);
    }

    // Explicit visit for the 'structure' parser rule (used in Heads)
    @Override
    public Structure visitStructure(LogicMiniParser.StructureContext ctx) {
        String functor = ctx.ATOM().getText();
        List<Term> args = new ArrayList<>();
        if (ctx.term_list() != null) {
            args = (List<Term>) visit(ctx.term_list());
        }
        return new Structure(functor, args);
    }

    @Override
    public Atom visitAtomTerm(LogicMiniParser.AtomTermContext ctx) {
        // In this simple AST, we can treat Atoms as Structures with 0 arguments
        // OR return a specific Atom object. Let's stick to strict types:
        return new Atom(ctx.getText());
    }

    @Override
    public Variable visitVariableTerm(LogicMiniParser.VariableTermContext ctx) {
        return new Variable(ctx.getText());
    }

    @Override
    public Object visitQuery(LogicMiniParser.QueryContext ctx) {
        // A query is just a term_list, so we visit it and return the resulting list.
        return visit(ctx.term_list());
    }

}