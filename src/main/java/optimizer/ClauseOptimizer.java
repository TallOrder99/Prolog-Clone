package optimizer;

import ast.Clause;
import ast.Program;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class ClauseOptimizer {

    /**
     * Reorganizes the clauses in a program for more efficient execution.
     * The primary optimization is to ensure that for any given predicate,
     * facts are always checked before rules.
     *
     * @param originalProgram The program AST generated by the parser.
     * @return A new Program object with the clauses reordered.
     */
    public Program optimize(Program originalProgram) {
        List<Clause> originalClauses = originalProgram.getClauses();

        // Step 1: Group clauses by their unique signature (functor + arity).
        // This ensures we don't mix clauses for 'parent/2' with 'cat/1'.
        Map<String, List<Clause>> groupedBySignature = originalClauses.stream()
                .collect(Collectors.groupingBy(c ->
                        c.getHead().getFunctor() + "/" + c.getHead().getArity()
                ));

        List<Clause> optimizedClauses = new ArrayList<>();

        // Step 2: For each group, sort the clauses so facts come first.
        for (List<Clause> group : groupedBySignature.values()) {

            // This sort is "stable," meaning if two elements are equal
            // (e.g., both are facts), their original relative order is preserved.
            group.sort((c1, c2) -> {
                boolean c1IsFact = c1.isFact();
                boolean c2IsFact = c2.isFact();

                if (c1IsFact && !c2IsFact) {
                    return -1; // c1 (the fact) should come before c2 (the rule).
                }
                if (!c1IsFact && c2IsFact) {
                    return 1;  // c2 (the fact) should come before c1 (the rule).
                }
                return 0;      // Both are facts or both are rules, keep original order.
            });

            // Step 3: Add the sorted group to our final list.
            optimizedClauses.addAll(group);
        }

        // Step 4: Create a new Program object with the optimized clause list.
        return new Program(optimizedClauses, originalProgram.getQuery());
    }
}